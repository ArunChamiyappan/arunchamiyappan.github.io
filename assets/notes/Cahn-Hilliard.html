<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Arun Chamiyappan</title>
  <link rel="stylesheet" href="../css/style.css" />
  <link rel="stylesheet" href="../css/contact.css"/>
  <link rel="stylesheet" href="../css/navbar.css"/>
  
</head>
<body>
  <header>
    <h1>Arun Chamiyappan</h1>
    <h3>PhD Student | IIT Madras</h3>
    <nav class="navbar">
      <ul class="navbar-menu">
        <li><a href="../../index.html">About</a></li>
        <li><a href="../../pages/CV.html">CV</a></li>
        <li><a href="../../pages/research.html">Research</a></li>
        <li class="dropdown">
          <a href="#">Teaching ▾</a>
          <ul class="dropdown-content">
            <li><a href="../../pages/Teaching.html">Teaching Assistance</a></li>
            <li><a href="../../pages/Notes.html">Notes</a></li>
          </ul>
        </li>
        <li><a href="../../pages/publications.html">Publications</a></li>
        <li><a href="https://github.com/ArunChamiyappan">GitHub</a></li>
      </ul>
    </nav>
  </header>

  <script
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"
  type="text/javascript"></script>


  <main>

    <h1>Cahn-Hilliard Equation</h1>

    <p>The <strong> Cahn-Hilliard equation</strong> is a fourth-order partial differential equation that models phase separation in binary mixtures, 
      a process called spinodal decomposition, where a homogeneous mixture spontaneously separates into two distinct, pure domains. 
      It describes how the phase field (a measure of the local concentration difference) evolves over time, driven by a combination of diffusion, interfacial energy, 
      and mass conservation. The equation has wide applications beyond materials science, including tumer growth modeling and multiphase fluid flows.
    </p>

    <h3 class="unnumbered" id="free-energy-functional">Free Energy Functional</h3>
    <p>The model is based on a total free energy functional: 
      <span class="math display">\[F[c] = \int_\Omega \left( \frac{\epsilon^2}{2} |\nabla c|^2 + f(c) \right) \, d\mathbf{x},\]</span>
    where
    </p>

    <ul>
      <li><p><span class="math inline">\(\epsilon\)</span> controls the interface width (gradient energy coefficient),</p></li>
      <li><p><span class="math inline">\(f(c)\)</span> is a double-well potential. Here we choose 
        <span class="math display">\[f(c) = W c^2 (1 - c)^2\]</span> 
        which favors two stable states: <span class="math inline">\(c = 0\)</span> and 
        <span class="math inline">\(c = 1\)</span>.</p></li>
    </ul>

    <h3 class="unnumbered" id="evolution-equation">Evolution Equation</h3>
    <p>The Evolution equation for the Cahn-Hilliard model is derived from the variational derivative of the free energy functional, leading to a conserved dynamics of concentration.
      <span class="math display">\[\frac{\partial c}{\partial t} = \nabla \cdot (M \nabla \mu )\]</span> 
      where
      <span class="math inline">\(\mu\)</span> is the chemical potential
      <span class="math display">\[\mu = \frac{\delta f}{\delta c} -\epsilon^2 \nabla^2 c \]</span>
      <span class="math display">\[\frac{\delta f}{\delta c} = 2 W c (1 - c) (1 - 2 c)\]</span>
    </p>


    <!-- Small iteractive simulation of Allen cahn equation-->
    <div class="simulation">

          <h3>Interactive simulation</h3>
        
          <div>
            <label>K: <input type="range" id="K" min="0" max="5" step="1" value="1"> <span id="Kval">1</span></label>
            <label>W: <input type="range" id="W" min="0" max="5" step="1" value="1"> <span id="Wval">1</span></label>
            <label>M: <input type="range" id="M" min="0" max="5" step="1" value="1"> <span id="Mval">1</span></label>
            <label>dt: <input type="range" id="dt" min="0.001" max="0.1" step="0.001" value="0.005"> <span id="dtval">0.01</span></label>
            <label>FPS: <input type="range" id="fps" min="1" max="30" step="1" value="10"> <span id="fpsval">10</span></label>
            <label>Colormap: <select id="colormap">
                <option value="jet">Jet</option>
                <option value="viridis">Viridis</option>
                <option value="gray">Gray</option>
              </select></label>
            <button onclick="start()">Restart</button>
          </div>
      
          <div class="sim-display">
            <canvas id="canvas" width="400" height="400"></canvas>
            <div class="colorbar-panel">
              <canvas id="colorbar" width="20" height="200" aria-hidden="true"></canvas>
              <div class="colorbar-labels">
                <div class="colorbar-max">1.00</div>
                <div class="colorbar-min">0.00</div>
              </div>
            </div>
          </div>
          <p id="timeDisplay">Simulation Time: 0.000</p>

          <script>
            const canvas = document.getElementById("canvas");
            const ctx = canvas.getContext("2d");
            const width = canvas.width;
            const height = canvas.height;
            const N = width;
            const dx = 1.0;
        
            let phi = new Array(N).fill().map(() => new Array(N).fill(0));
            let phi_new = new Array(N).fill().map(() => new Array(N).fill(0));
            let laplacian = new Array(N).fill().map(() => new Array(N).fill(0));
        
            let K = 1.0; W = 1.0, M = 1.0, dt = 0.01, fps = 10;
            let frameDelay = 1000 / fps;
            let running = false;
            let simTime = 0.0;
            const timeDisplay = document.getElementById("timeDisplay");
        
            function updateSliders() {
              K = parseFloat(document.getElementById('K').value);
              W = parseFloat(document.getElementById('W').value);
              M = parseFloat(document.getElementById('M').value);
              dt = parseFloat(document.getElementById('dt').value);
              fps = parseInt(document.getElementById('fps').value);
              frameDelay = 1000 / fps;
              document.getElementById('Kval').textContent = K;
              document.getElementById('Wval').textContent = W;
              document.getElementById('Mval').textContent = M;
              document.getElementById('dtval').textContent = dt;
              document.getElementById('fpsval').textContent = fps;
            }
        
            document.querySelectorAll("input[type=range]").forEach(input => {
              input.addEventListener("input", updateSliders);
            });
        
            function initialize() {
              for (let i = 0; i < N; i++) {
                for (let j = 0; j < N; j++) {
                  phi[i][j] = Math.random();
                }
              }
                simTime = 0.0;
                updateTimeDisplay();
            }
        
            function step() {
              for (let i = 1; i < N - 1; i++) {
                for (let j = 1; j < N - 1; j++) {
                    let lap = (phi[i + 1][j] + phi[i - 1][j] + phi[i][j + 1] + phi[i][j - 1] - 4 * phi[i][j]) / (dx * dx);
                    let f_h_phi = 2 * W * phi[i][j] * (1-phi[i][j]) * (1-2*phi[i][j]);
                  laplacian[i][j] = f_h_phi - K * lap;
                }
              }

              for (let i = 1; i < N - 1; i++) {
                for (let j = 1; j < N - 1; j++) {
                    let delta_phi = phi[i][j] + dt * M * ((laplacian[i + 1][j] + laplacian[i - 1][j] + laplacian[i][j + 1] + laplacian[i][j - 1] - 4 * laplacian[i][j]) / (dx * dx));

                    if(delta_phi < 0) phi_new[i][j] = 0;
                    else if(delta_phi > 1) phi_new[i][j] = 1;
                    else phi_new[i][j] = delta_phi;
                  }
              }
          
              // Neumann BC
              for (let i = 0; i < N; i++) {
                phi_new[i][0] = phi_new[i][1];
                phi_new[i][N - 1] = phi_new[i][N - 2];
                phi_new[0][i] = phi_new[1][i];
                phi_new[N - 1][i] = phi_new[N - 2][i];
              }
          
              [phi, phi_new] = [phi_new, phi];
                simTime += dt;
                updateTimeDisplay();
            }

            function updateTimeDisplay() {
              timeDisplay.textContent = `Simulation Time: ${simTime.toFixed(3)}`;
            }
        
            function jetColorMap(val) {
              // val in [0, 1]
              let r = Math.min(1, Math.max(0, 1.5 - 4 * Math.abs(val - 0.75)));
              let g = Math.min(1, Math.max(0, 1.5 - 4 * Math.abs(val - 0.5)));
              let b = Math.min(1, Math.max(0, 1.5 - 4 * Math.abs(val - 0.25)));
              return [r * 255, g * 255, b * 255];
            }

            function grayColorMap(val) {
              const v = Math.round(val * 255);
              return [v, v, v];
            }

            // Simple viridis-like palette (approximation)
            function viridisColorMap(val) {
              // Coefficients taken from a common viridis approximation
              const c = [
                [0.267004,0.004874,0.329415],
                [0.190631,0.407061,0.556089],
                [0.20803,0.718701,0.472873],
                [0.993248,0.906157,0.143936]
              ];
              // simple interpolation across four stops
              const t = Math.max(0, Math.min(1, val));
              const idx = Math.floor(t * (c.length - 1));
              const frac = (t * (c.length - 1)) - idx;
              const a = c[idx];
              const b = c[Math.min(idx + 1, c.length - 1)];
              const r = Math.round((a[0] + (b[0]-a[0]) * frac) * 255);
              const g = Math.round((a[1] + (b[1]-a[1]) * frac) * 255);
              const bl = Math.round((a[2] + (b[2]-a[2]) * frac) * 255);
              return [r, g, bl];
            }

            // Current colormap function (default jet)
            let currentColorMap = jetColorMap;

            document.getElementById('colormap').addEventListener('change', (e) => {
              const v = e.target.value;
              if (v === 'jet') currentColorMap = jetColorMap;
              else if (v === 'viridis') currentColorMap = viridisColorMap;
              else if (v === 'gray') currentColorMap = grayColorMap;
              drawColorbar();
            });

            function drawColorbar() {
              const cb = document.getElementById('colorbar');
              if (!cb) return;
              const cctx = cb.getContext('2d');
              const w = cb.width;
              const h = cb.height;
              const img = cctx.createImageData(w, h);
              // vertical colorbar: y=0 top -> max (1.0), y=h-1 bottom -> min (0.0)
              for (let y = 0; y < h; y++) {
                const t = 1 - (y / (h - 1));
                const [r,g,b] = currentColorMap(t);
                for (let x = 0; x < w; x++) {
                  const idx = (y * w + x) * 4;
                  img.data[idx] = r;
                  img.data[idx+1] = g;
                  img.data[idx+2] = b;
                  img.data[idx+3] = 255;
                }
              }
              cctx.putImageData(img, 0, 0);
              // update numeric labels
              const maxLabel = document.querySelector('.colorbar-max');
              const minLabel = document.querySelector('.colorbar-min');
              if (maxLabel) maxLabel.textContent = '1.00';
              if (minLabel) minLabel.textContent = '0.00';
            }
        
            function draw() {
              let image = ctx.createImageData(N, N);
              for (let i = 0; i < N; i++) {
                for (let j = 0; j < N; j++) {
                  let idx = (j * N + i) * 4;
                  let norm_val = (phi[i][j] + 1) / 2; // [-1,1] → [0,1]
                  let [r, g, b] = currentColorMap(norm_val);
                
                  image.data[idx + 0] = r;
                  image.data[idx + 1] = g;
                  image.data[idx + 2] = b;
                  image.data[idx + 3] = 255;
                }
              }
              ctx.putImageData(image, 0, 0);
            }
        
            function simulate() {
              if (!running) return;
              step();
              draw();
              setTimeout(simulate, frameDelay);
            }
        
            function start() {
              running = false;
              updateSliders();
              initialize();
              setTimeout(() => {
                running = true;
                simulate();
              }, 100);
            }
        
            // Draw the initial colorbar and start the simulation
            drawColorbar();
            start();
          </script>


      </p>
    </div>



    <!-- 3D Cahn-Hilliard animation -->
    <section class="media-container" id="cahn-hilliard-animation">
      <h3 style="text-align:center;">3D Cahn–Hilliard Animation</h3>
      <video controls preload="metadata" poster="../images/Cahn-Hilliard-poster.png">
        <source src="../animations/Cahn-Hilliard_3D.mp4" type="video/mp4">
        Your browser does not support the video tag. You can
        <a href="../animations/Cahn-Hilliard_3D.mp4">download the animation</a> instead.
      </video>
      <div class="media-caption">A volumetric 3D visualization of the Cahn–Hilliard evolution.</div>
    </section>

    <note>
    <p>The <strong> SYCL </strong> programme used for the simulation is available online <a href="https://github.com/gphanikumar/hpc/tree/main/Parallel_Programming/SYCL/Cahn-Hilliard_fdm_3D">here</a>.</p>


  </main>


  <footer>
    <p>Arun Chamiyappan  | Indian Institute of Technology Madras | mm23d002@smail.iitm.ac.in</p>
  </footer>
</body>
</html>
